# 二、项目思路与框架说明（架构、输入输出）
## 总体架构（微服务）
### Node.js（Express + Sequelize + MySQL）
职责：用户认证、积分管理、记录存档；对接前端；调用 Python 微服务
关键目录：
    controllers：authController / pointsController / essayController / adminController
    routes：authRoutes / pointsRoutes / essayRoutes / adminRoutes
    models：User / PointsTransaction / EssayRecord / BetaCode
### Python（FastAPI + Celery + Redis）
职责：AI 批改与 PDF 生成；调用 DashScope（Qwen）
关键点：
    POST /grade_essay（接收图片，排队异步任务）
    GET /result/{task_id}（查询 JSON/PDF 生成结果）
    Celery 消费任务：grade_essay_multipage → 调模型 → 生成/保存 runs/… → 返回路径
## 数据流（输入→处理→输出）
### 输入（来源：浏览器）
Node /api/essay/submit（multipart/form-data：images 多文件；可选 prompt 文本）
Node 扣积分，创建 EssayRecord（status=processing），异步调用 Python /grade_essay
### 中间（Python 处理）
FastAPI 接收 → Celery 入队 → 调用 DashScope qwen-vl-xxx → 产出 JSON 结果
调用 export-pdf.js（Puppeteer）将 JSON 渲染成 PDF，保存至 runs/<时间戳_随机>/ 下
### 输出（回前端）
Node /api/essay/result/:recordId 根据 recordId 取 celery_task_id 调 Python /result/{task_id}
将完成结果写回 EssayRecord.ai_feedback（JSON串）和 status（completed/failed），并将 result 返回给前端
返回体包含 result.pdf_path / result.json_path，便于核对
## 关键输入输出位置
输入：
Node /api/essay/submit：form-data 字段 images（多文件）；可选 prompt（文本）
输出：
Python 侧落盘：runs/<时间戳_随机>/qwen_essay_result.json、essay_report.pdf
Node 侧持久化：EssayRecord（status/ai_feedback/celery_task_id）
前端可见：/api/essay/result/:recordId 返回 JSON（含 pdf_path/json_path）
## 遗留问题：
此外，请确认数据库表字段 status 已包含 'failed'，若历史库仍旧，执行：
ALTER TABLE essay_records
MODIFY status ENUM('processing','completed','failed') NOT NULL DEFAULT 'processing';
现在是通过yonghuguanli\yonghuguanli\server.js的
await sequelize.sync({ alter: true });暂时解决状态列表没有fail字段问题